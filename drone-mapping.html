<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Drone Mapping ‚Äî Wings Of Discovery</title>
    <link rel="stylesheet" href="css/style.css" />
    <style>
      .planner-container {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
        max-width: 1200px;
        margin: 0 auto;
      }
      .canvas-section {
        flex: 1;
        min-width: 300px;
        background: var(--card);
        padding: 16px;
        border-radius: var(--radius);
        box-shadow: 0 6px 18px rgba(20, 30, 60, 0.04);
      }
      canvas {
        border: 2px solid #ddd;
        border-radius: 6px;
        display: block;
        width: 100%;
        max-width: 600px;
        cursor: crosshair;
        background: #fafbfc;
      }
      .controls {
        margin-top: 12px;
      }
      button {
        padding: 8px 14px;
        margin: 4px 4px 4px 0;
        background: var(--accent);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9rem;
      }
      button:hover {
        background: #1a5cbf;
      }
      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      #exportBtn {
        background: #27ae60;
      }
      #exportBtn:hover {
        background: #1e8449;
      }
      #exportBtn:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      #deletePointBtn {
        background: #e74c3c;
      }
      #deletePointBtn:hover:not(:disabled) {
        background: #c0392b;
      }
      #deletePointBtn:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      .code-modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
      }
      .code-modal.active {
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .code-content {
        background: white;
        padding: 24px;
        border-radius: 8px;
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      }
      .code-content h2 {
        margin-top: 0;
      }
      .code-block {
        background: #f5f5f5;
        padding: 12px;
        border-radius: 4px;
        font-family: monospace;
        font-size: 0.85rem;
        overflow-x: auto;
        white-space: pre-wrap;
        word-wrap: break-word;
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #ddd;
      }
      .close-btn {
        background: #e74c3c;
        padding: 8px 16px;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin-top: 12px;
      }
      .close-btn:hover {
        background: #c0392b;
      }
      .copy-btn {
        background: #2b7aee;
        padding: 8px 16px;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin-right: 8px;
      }
      .copy-btn:hover {
        background: #1a5cbf;
      }
      .info-section {
        flex: 1;
        min-width: 280px;
        background: var(--card);
        padding: 16px;
        border-radius: var(--radius);
        box-shadow: 0 6px 18px rgba(20, 30, 60, 0.04);
      }
      .info-section h3 {
        margin-top: 0;
      }
      .info-item {
        margin: 10px 0;
        padding: 10px;
        background: #f5f9ff;
        border-radius: 4px;
      }
      .legend {
        margin-top: 16px;
        font-size: 0.9rem;
      }
      .legend-item {
        display: flex;
        align-items: center;
        margin: 6px 0;
      }
      .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 3px;
        margin-right: 8px;
      }
    </style>
  </head>
  <body>
    <header class="site-header small">
      <h1>üöÅ Drone Mapping</h1>
      <nav class="main-nav">
        <a href="index.html">üè† Home</a>
        <a href="ai-image-detecting.html">üß† AI Image Detecting</a>
        <a href="about.html">üë©‚Äçüë©‚Äçüëß‚Äçüë¶ About Us</a>
      </nav>
    </header>

    <main class="container">
      <article>
        <h2>Interactive Drone Path Planner</h2>
        <p>
          Draw a polygon on the canvas to show the area you want to map. Click
          "Find Path" to see the smallest rectangle that fits and the drone
          flight paths spaced 5 feet apart.
        </p>

        <div class="planner-container">
          <div class="canvas-section">
            <h3>Draw Area</h3>
            <canvas id="canvas"></canvas>
            <div class="controls">
              <button id="findPathBtn">üéØ Find Path</button>
              <button id="clearBtn">üóëÔ∏è Clear</button>
              <button id="undoBtn">‚Ü∂ Undo</button>
              <button id="deletePointBtn" disabled>‚ùå Delete Point</button>
              <button id="exportBtn">üì• Export to Drone Blocks</button>
            </div>
            <div
              style="margin-top: 8px; font-size: 0.85rem; color: var(--muted)"
            >
              Click on canvas to add points. Click a point to select it, then
              click "Delete Point". Right-click a point to delete it.
            </div>
          </div>

          <div class="info-section">
            <h3>Flight Info</h3>
            <div class="info-item">
              <strong>Polygon Points:</strong> <span id="pointCount">0</span>
            </div>
            <div class="info-item">
              <strong>Rectangle Width:</strong> <span id="rectWidth">‚Äî</span> px
            </div>
            <div class="info-item">
              <strong>Rectangle Height:</strong>
              <span id="rectHeight">‚Äî</span> px
            </div>
            <div class="info-item">
              <strong>Flight Paths:</strong> <span id="pathCount">0</span>
            </div>
            <div class="info-item">
              <strong>Drone FOV:</strong>
              <input
                type="number"
                id="pathSpacing"
                min="1"
                max="50"
                value="5"
                style="
                  width: 60px;
                  padding: 4px;
                  border: 1px solid #ddd;
                  border-radius: 3px;
                "
              />
              feet
            </div>
            <div class="info-item">
              <strong>Pixel Scale:</strong>
              <input
                type="number"
                id="pixelScale"
                min="0.1"
                max="20"
                step="0.1"
                value="0.25"
                style="
                  width: 60px;
                  padding: 4px;
                  border: 1px solid #ddd;
                  border-radius: 3px;
                "
              />
              ft/px
            </div>
            <div class="info-item">
              <strong>Drone Speed:</strong>
              <input
                type="number"
                id="droneSpeed"
                min="5"
                max="100"
                value="25"
                style="
                  width: 60px;
                  padding: 4px;
                  border: 1px solid #ddd;
                  border-radius: 3px;
                "
              />
              mph
            </div>
            <div class="info-item">
              <strong>Flight Time:</strong>
              <span id="flightTime">‚Äî</span> minutes
            </div>

            <div class="legend">
              <strong>Legend:</strong>
              <div class="legend-item">
                <div class="legend-color" style="background: #ff6b6b"></div>
                Polygon (your area)
              </div>
              <div class="legend-item">
                <div class="legend-color" style="background: #4ecdc4"></div>
                Bounding rectangle
              </div>
              <div class="legend-item">
                <div class="legend-color" style="background: #95e1d3"></div>
                Flight paths
              </div>
            </div>
          </div>
        </div>

        <h3 style="margin-top: 32px">How Drone Mapping Works</h3>
        <p>
          Drone mapping uses a small flying drone to take many overlapping
          pictures of an area from above. These pictures are then combined using
          software to create a map or 3D model. It's useful for:
        </p>
        <ul>
          <li>Surveying land before building projects</li>
          <li>Creating maps of parks or gardens</li>
          <li>Measuring areas or tracking changes over time</li>
          <li>Inspecting roofs or tall structures safely</li>
        </ul>

        <p class="note">
          ‚úàÔ∏è <strong>Safety First:</strong> Always follow local rules, fly in
          safe open areas, and have a grown-up supervise!
        </p>
      </article>
    </main>

    <div id="codeModal" class="code-modal">
      <div class="code-content">
        <h2>Drone Blocks Flight Plan Code</h2>
        <p>Copy this code into Drone Blocks to execute your flight plan:</p>
        <div class="code-block" id="droneBlocksCode"></div>
        <button class="copy-btn" onclick="copyToClipboard()">
          üìã Copy Code
        </button>
        <button class="close-btn" onclick="closeCodeModal()">Close</button>
      </div>
    </div>

    <footer class="site-footer">
      <small>Back to <a href="index.html">Home</a></small>
    </footer>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const findPathBtn = document.getElementById("findPathBtn");
      const clearBtn = document.getElementById("clearBtn");
      const undoBtn = document.getElementById("undoBtn");
      const exportBtn = document.getElementById("exportBtn");
      const deletePointBtn = document.getElementById("deletePointBtn");
      const pointCountEl = document.getElementById("pointCount");
      const rectWidthEl = document.getElementById("rectWidth");
      const rectHeightEl = document.getElementById("rectHeight");
      const pathCountEl = document.getElementById("pathCount");
      const pixelScaleInput = document.getElementById("pixelScale");
      const pathSpacingInput = document.getElementById("pathSpacing");
      const droneSpeedInput = document.getElementById("droneSpeed");
      const flightTimeEl = document.getElementById("flightTime");

      let points = [];
      let showPath = false;
      let boundingRect = null;
      let flightPaths = [];
      let selectedPointIndex = -1;

      // Update flight paths when scale or spacing changes
      pixelScaleInput.addEventListener("change", () => {
        if (showPath && boundingRect) {
          flightPaths = calculateFlightPaths();
          pathCountEl.textContent = flightPaths.length;
          redraw();
        }
      });

      pathSpacingInput.addEventListener("change", () => {
        if (showPath && boundingRect) {
          flightPaths = calculateFlightPaths();
          pathCountEl.textContent = flightPaths.length;
          updateFlightTime();
          redraw();
        }
      });

      droneSpeedInput.addEventListener("change", () => {
        if (showPath) {
          updateFlightTime();
        }
      });

      // Point dragging
      let draggingPointIndex = -1;

      canvas.addEventListener("mousedown", (e) => {
        if (showPath) return; // Don't drag points after path is shown
        const pos = getMousePos(e);
        // Check if mouse is near a point
        for (let i = 0; i < points.length; i++) {
          const dist = Math.sqrt(
            Math.pow(pos.x - points[i].x, 2) + Math.pow(pos.y - points[i].y, 2)
          );
          if (dist < 10) {
            draggingPointIndex = i;
            break;
          }
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        if (draggingPointIndex >= 0) {
          const pos = getMousePos(e);
          points[draggingPointIndex] = pos;
          redraw();
        }
      });

      canvas.addEventListener("mouseup", () => {
        draggingPointIndex = -1;
      });

      canvas.addEventListener("mouseleave", () => {
        draggingPointIndex = -1;
      });

      // Point selection
      canvas.addEventListener("click", (e) => {
        if (showPath) return; // Don't select points after path is shown
        if (draggingPointIndex >= 0) return; // Don't select if we just dragged

        const pos = getMousePos(e);
        selectedPointIndex = -1;

        // Check if clicked on a point
        for (let i = 0; i < points.length; i++) {
          const dist = Math.sqrt(
            Math.pow(pos.x - points[i].x, 2) + Math.pow(pos.y - points[i].y, 2)
          );
          if (dist < 10) {
            selectedPointIndex = i;
            break;
          }
        }

        // Update UI
        if (selectedPointIndex >= 0) {
          deletePointBtn.disabled = false;
          deletePointBtn.textContent = `Delete Point ${selectedPointIndex + 1}`;
        } else {
          deletePointBtn.disabled = true;
          deletePointBtn.textContent = "Delete Point";
        }

        redraw();
      });

      // Delete point button
      deletePointBtn.addEventListener("click", () => {
        if (selectedPointIndex >= 0 && selectedPointIndex < points.length) {
          points.splice(selectedPointIndex, 1);
          selectedPointIndex = -1;
          deletePointBtn.disabled = true;
          deletePointBtn.textContent = "Delete Point";
          pointCountEl.textContent = points.length;
          redraw();
        }
      });

      // Resize canvas to fit container
      function resizeCanvas() {
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = Math.min(600, rect.width - 32);
        canvas.height = 500;
        redraw();
      }
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      // Get mouse position relative to canvas
      function getMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        return {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top,
        };
      }

      // Draw everything
      function redraw() {
        ctx.fillStyle = "#fafbfc";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw polygon
        if (points.length > 0) {
          ctx.strokeStyle = "#ff6b6b";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
          }
          if (points.length > 2) {
            ctx.lineTo(points[0].x, points[0].y);
          }
          ctx.stroke();

          // Draw points
          points.forEach((p, i) => {
            // Highlight selected point
            if (i === selectedPointIndex) {
              ctx.fillStyle = "#2ecc71";
              ctx.beginPath();
              ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
              ctx.fill();
            }

            ctx.fillStyle = "#ff6b6b";
            ctx.beginPath();
            ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#333";
            ctx.font = "bold 10px Arial";
            ctx.fillText(i + 1, p.x + 8, p.y - 8);

            // Draw distance to next point
            if (i < points.length - 1) {
              const nextP = points[i + 1];
              const distPx = Math.sqrt(
                Math.pow(nextP.x - p.x, 2) + Math.pow(nextP.y - p.y, 2)
              );
              const feetPerPixel = parseFloat(pixelScaleInput.value) || 0.25;
              const distFt = distPx * feetPerPixel;
              const midX = (p.x + nextP.x) / 2;
              const midY = (p.y + nextP.y) / 2;
              ctx.fillStyle = "#666";
              ctx.font = "11px Arial";
              ctx.fillText(distFt.toFixed(1) + " ft", midX - 20, midY - 5);
            }
          });
        }

        // Draw bounding rectangle and paths
        if (showPath && boundingRect) {
          // Draw rectangle
          ctx.strokeStyle = "#4ecdc4";
          ctx.lineWidth = 3;
          ctx.strokeRect(
            boundingRect.x,
            boundingRect.y,
            boundingRect.w,
            boundingRect.h
          );

          // Draw flight paths
          ctx.strokeStyle = "#95e1d3";
          ctx.lineWidth = 2;
          flightPaths.forEach((path) => {
            ctx.beginPath();
            ctx.moveTo(path.x1, path.y1);
            ctx.lineTo(path.x2, path.y2);
            ctx.stroke();
          });

          // Draw path direction arrows
          ctx.fillStyle = "#95e1d3";
          flightPaths.forEach((path, idx) => {
            const midX = (path.x1 + path.x2) / 2;
            const midY = (path.y1 + path.y2) / 2;
            const arrowSize = 6;
            if (idx % 2 === 0) {
              // Arrow pointing right
              ctx.beginPath();
              ctx.moveTo(midX, midY);
              ctx.lineTo(midX - arrowSize, midY - arrowSize / 2);
              ctx.lineTo(midX - arrowSize, midY + arrowSize / 2);
              ctx.closePath();
            } else {
              // Arrow pointing left
              ctx.beginPath();
              ctx.moveTo(midX, midY);
              ctx.lineTo(midX + arrowSize, midY - arrowSize / 2);
              ctx.lineTo(midX + arrowSize, midY + arrowSize / 2);
              ctx.closePath();
            }
            ctx.fill();
          });
        }
      }

      // Calculate bounding rectangle
      function calculateBoundingRect() {
        if (points.length < 3) return null;

        let minX = points[0].x;
        let maxX = points[0].x;
        let minY = points[0].y;
        let maxY = points[0].y;

        points.forEach((p) => {
          minX = Math.min(minX, p.x);
          maxX = Math.max(maxX, p.x);
          minY = Math.min(minY, p.y);
          maxY = Math.max(maxY, p.y);
        });

        return {
          x: minX,
          y: minY,
          w: maxX - minX,
          h: maxY - minY,
        };
      }

      // Calculate flight paths (spacing based on feet per pixel scale)
      function calculateFlightPaths() {
        if (!boundingRect) return [];
        const feetPerPixel = parseFloat(pixelScaleInput.value) || 0.25;
        const pathSpacingFeet = parseFloat(pathSpacingInput.value) || 5;
        const spacing = pathSpacingFeet / feetPerPixel; // Convert feet spacing to pixels
        const paths = [];
        for (
          let y = boundingRect.y + spacing;
          y < boundingRect.y + boundingRect.h;
          y += spacing
        ) {
          const x1 = boundingRect.x;
          const x2 = boundingRect.x + boundingRect.w;
          paths.push({ x1, y1: y, x2, y2: y });
        }
        return paths;
      }

      // Calculate flight time
      function updateFlightTime() {
        if (!flightPaths || flightPaths.length === 0) {
          flightTimeEl.textContent = "‚Äî";
          return;
        }

        const feetPerPixel = parseFloat(pixelScaleInput.value) || 0.25;
        const droneSpeedMph = parseFloat(droneSpeedInput.value) || 25;
        const droneSpeedFtPerSec = (droneSpeedMph * 5280) / 3600; // Convert mph to ft/sec

        // Calculate total distance of all flight paths
        let totalDistance = 0;
        flightPaths.forEach((path, idx) => {
          const pathLengthPx = Math.abs(path.x2 - path.x1);
          const pathLengthFt = pathLengthPx * feetPerPixel;
          totalDistance += pathLengthFt;

          // Add turning distance between paths (accounts for drone turning at end of each path)
          if (idx < flightPaths.length - 1) {
            const nextPath = flightPaths[idx + 1];
            const verticalDistPx = Math.abs(nextPath.y1 - path.y1);
            const verticalDistFt = verticalDistPx * feetPerPixel;
            totalDistance += verticalDistFt; // Add vertical distance for the turn
          }
        });

        // Add overhead time for acceleration, deceleration, and image capture (~20% overhead)
        const overheadMultiplier = 1.2;
        const totalDistanceWithOverhead = totalDistance * overheadMultiplier;

        // Calculate flight time in seconds, then convert to minutes
        const flightTimeSeconds =
          totalDistanceWithOverhead / droneSpeedFtPerSec;
        const flightTimeMinutes =
          Math.round((flightTimeSeconds / 60) * 10) / 10; // Round to 1 decimal

        flightTimeEl.textContent = flightTimeMinutes.toFixed(1);
      }

      // Canvas click - only add point if we didn't drag
      canvas.addEventListener("click", (e) => {
        if (showPath) return; // Don't add points after path is shown
        if (draggingPointIndex >= 0) return; // Don't add point if we were dragging
        const pos = getMousePos(e);

        // Check if clicking on an existing point
        let clickedPoint = false;
        for (let i = 0; i < points.length; i++) {
          const dist = Math.sqrt(
            Math.pow(pos.x - points[i].x, 2) + Math.pow(pos.y - points[i].y, 2)
          );
          if (dist < 10) {
            clickedPoint = true;
            break;
          }
        }

        // Only add new point if not clicking on existing point
        if (!clickedPoint) {
          points.push(pos);
          pointCountEl.textContent = points.length;
        }
        redraw();
      });

      // Find path
      findPathBtn.addEventListener("click", () => {
        if (points.length < 3) {
          alert("Please draw at least 3 points to form a polygon.");
          return;
        }
        showPath = true;
        boundingRect = calculateBoundingRect();
        flightPaths = calculateFlightPaths();
        rectWidthEl.textContent = Math.round(boundingRect.w) + " px";
        rectHeightEl.textContent = Math.round(boundingRect.h) + " px";
        pathCountEl.textContent = flightPaths.length;
        updateFlightTime();
        findPathBtn.disabled = true;
        exportBtn.disabled = false;
        redraw();
      });

      // Clear
      clearBtn.addEventListener("click", () => {
        points = [];
        showPath = false;
        boundingRect = null;
        flightPaths = [];
        pointCountEl.textContent = "0";
        rectWidthEl.textContent = "‚Äî";
        rectHeightEl.textContent = "‚Äî";
        pathCountEl.textContent = "0";
        flightTimeEl.textContent = "‚Äî";
        findPathBtn.disabled = false;
        exportBtn.disabled = true;
        redraw();
      });

      // Undo
      undoBtn.addEventListener("click", () => {
        if (points.length > 0) {
          points.pop();
          pointCountEl.textContent = points.length;
          redraw();
        }
      });

      // Export to Drone Blocks
      exportBtn.addEventListener("click", () => {
        if (!showPath || !flightPaths || flightPaths.length === 0) {
          alert("Please generate a flight path first.");
          return;
        }
        generateDroneBlocksCode();
        document.getElementById("codeModal").classList.add("active");
      });

      // Generate Drone Blocks code
      function generateDroneBlocksCode() {
        const feetPerPixel = parseFloat(pixelScaleInput.value) || 0.25;
        const droneSpeed = parseFloat(droneSpeedInput.value) || 25;

        let code = `# Drone Mapping Flight Plan\n`;
        code += `# Generated by Wings of Discovery\n\n`;
        code += `# Drone Settings\n`;
        code += `drone.set_max_flight_height(400)  # Set to your desired altitude\n`;
        code += `drone.set_speed(${droneSpeed})  # Speed in mph\n`;
        code += `drone.start_mission()\n\n`;
        code += `# Takeoff\n`;
        code += `drone.takeoff()\n\n`;

        code += `# Flight path with ${flightPaths.length} passes\n`;
        flightPaths.forEach((path, idx) => {
          const pathLengthPx = Math.abs(path.x2 - path.x1);
          const pathLengthFt = pathLengthPx * feetPerPixel;
          const yPosFt = path.y1 * feetPerPixel;

          code += `# Pass ${idx + 1} (${pathLengthFt.toFixed(1)} feet)\n`;
          code += `drone.move_distance_forward(${pathLengthFt.toFixed(
            1
          )}, feet)\n`;

          if (idx < flightPaths.length - 1) {
            const nextPath = flightPaths[idx + 1];
            const verticalDistPx = Math.abs(nextPath.y1 - path.y1);
            const verticalDistFt = verticalDistPx * feetPerPixel;
            code += `# Turn to next path\n`;
            code += `drone.move_distance_right(${verticalDistFt.toFixed(
              1
            )}, feet)\n`;
          }
          code += `\n`;
        });

        code += `# Return to Home\n`;
        code += `drone.rtk()  # Return to Home\n`;
        code += `drone.end_mission()\n`;

        document.getElementById("droneBlocksCode").textContent = code;
      }

      // Copy code to clipboard
      function copyToClipboard() {
        const code = document.getElementById("droneBlocksCode").textContent;
        navigator.clipboard
          .writeText(code)
          .then(() => {
            alert("Code copied to clipboard!");
          })
          .catch(() => {
            alert("Failed to copy. Please try again.");
          });
      }

      // Close code modal
      function closeCodeModal() {
        document.getElementById("codeModal").classList.remove("active");
      }

      // Close modal when clicking outside
      window.addEventListener("click", (e) => {
        const modal = document.getElementById("codeModal");
        if (e.target === modal) {
          modal.classList.remove("active");
        }
      });
    </script>
  </body>
</html>
